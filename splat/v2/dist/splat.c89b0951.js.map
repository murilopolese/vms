{"version":3,"sources":["splat.js"],"names":["format_matrix","ruleArray","formatted","offsetX","offsetY","length","y","x","Rule","when","then","match","grid","element","matching","_y","_x","symbol","value","name","empty","apply","elements","Element","rules","color","clearGrid","GRID_HEIGHT","GRID_WIDTH","push","i","c","String","fromCharCode","module","exports"],"mappings":";AAAA,SAASA,EAAcC,GACfC,IAAAA,EAAY,CAChB,CAAC,IAAK,IAAK,KACX,CAAC,IAAK,IAAK,KACX,CAAC,IAAK,IAAK,MAETC,EAAU,EACVC,EAAU,EACVH,EAAUI,OAAS,IACrBD,EAAU,GAERH,EAAU,GAAGI,OAAS,IACxBF,EAAU,GAGP,IAAA,IAAIG,EAAI,EAAGA,EAAIL,EAAUI,OAAQC,IAC/B,IAAA,IAAIC,EAAI,EAAGA,EAAIN,EAAUK,GAAGD,OAAQE,IACvCL,EAAUI,EAAEF,GAASG,EAAEJ,GAAWF,EAAUK,GAAGC,GAI5CL,OAAAA,EAGT,SAASM,EAAmC,GAA5BC,IAAAA,EAAAA,EAAAA,KAAAA,OAAO,IAAA,EAAA,CAAC,IAAoB,EAAfC,EAAAA,EAAAA,KAAAA,OAAO,IAAA,EAAA,CAAC,IAAO,EACrCD,KAAAA,KAAOT,EAAcS,GACrBC,KAAAA,KAAOV,EAAcU,GAErBC,KAAAA,MAAQ,SAASC,EAAML,EAAGD,GAIxB,IAHDO,IAAAA,EAAUD,EAAKN,GAAGC,GAElBO,GAAW,EACNC,EAAK,EAAGA,EAAK,EAAGA,IAClB,IAAA,IAAIC,EAAK,EAAGA,EAAK,EAAGA,IAAM,CACzBC,IAAAA,EAAS,KAAKR,KAAKM,GAAIC,GACvBE,EAAQN,EAAKN,EAAES,EAAG,GAAGR,EAAES,EAAG,GACtBC,OAAAA,GACD,IAAA,IACCC,EAAMC,OAASN,EAAQM,OACzBL,GAAW,GAEb,MACG,IAAA,IAEH,MACG,IAAA,IACCI,EAAMC,OAASC,EAAMD,OACvBL,GAAW,GAEb,MACG,IAAA,IACCI,EAAMC,OAASC,EAAMD,OACvBL,GAAW,GAEb,MACG,KAAA,KAEH,MACF,QACMI,EAAMC,KAAK,KAAOF,IACpBH,GAAW,IAKdA,OAAAA,GAGJO,KAAAA,MAAQ,SAAST,EAAML,EAAGD,GAGxB,IAFDO,IAAAA,EAAUD,EAAKN,GAAGC,GAEbQ,EAAK,EAAGA,EAAK,EAAGA,IAClB,IAAA,IAAIC,EAAK,EAAGA,EAAK,EAAGA,IAAM,CACzBC,IAAAA,EAAS,KAAKP,KAAKK,GAAIC,GACnBC,OAAAA,GACD,IAAA,IACHL,EAAKN,EAAES,EAAG,GAAGR,EAAES,EAAG,GAAKM,EAAST,EAAQM,MACxC,MACG,IAAA,IACA,IAAA,IACA,KAAA,KAEH,MACG,IAAA,IACDP,EAAKN,EAAES,EAAG,GAAGR,EAAES,EAAG,GAAKI,EACzB,MACF,QACER,EAAKN,EAAES,EAAG,GAAGR,EAAES,EAAG,GAAKM,EAASL,IAIjCL,OAAAA,GAIX,SAASW,EAAqD,GAA3CJ,IAAAA,EAAAA,EAAAA,KAAAA,OAAO,IAAA,EAAA,IAAoC,EAA/BK,EAAAA,EAAAA,MAAAA,OAAQ,IAAA,EAAA,GAAuB,EAAnBC,EAAAA,EAAAA,MAAAA,OAAQ,IAAA,EAAA,QAAW,EACvDN,KAAAA,KAAOA,EACPK,KAAAA,MAAQA,EACRC,KAAAA,MAAQA,EAGf,IAAIL,EAAQ,IAAIG,EAAQ,CAAEJ,KAAM,MAChC,SAASO,EAAUd,GACZA,IAAMA,EAAO,IACb,IAAA,IAAIN,EAAI,EAAGA,EAAIqB,EAAarB,IAAK,CACpCM,EAAKN,GAAK,GACL,IAAA,IAAIC,EAAI,EAAGA,EAAIqB,EAAYrB,IAC9BK,EAAKN,GAAGuB,KAAKT,GAGVR,OAAAA,EAKT,IAFA,IAAIU,EAAW,GAENQ,EAAI,GAAIA,EAAI,GAAIA,IAAK,CACxBC,IAAAA,EAAIC,OAAOC,aAAaH,GAC5BR,EAASS,GAAK,IAAIR,EAAQ,CAAEJ,KAASY,GAAAA,OAAAA,KAGvC,IAAMH,EAAa,GACbD,EAAc,GAChBf,EAAOc,IAEXQ,OAAOC,QAAU,CACfP,WAAAA,EACAD,YAAAA,EACAnB,KAAMA,EACNe,QAASA,EACTX,KAAMA,EACNU,SAAUA,EACVI,UAAWA","file":"splat.c89b0951.js","sourceRoot":"..","sourcesContent":["function format_matrix(ruleArray) {\n  const formatted = [\n    ['.', '.', '.'],\n    ['.', '.', '.'],\n    ['.', '.', '.']\n  ]\n  let offsetX = 0\n  let offsetY = 0\n  if (ruleArray.length < 3) {\n    offsetY = 1\n  }\n  if (ruleArray[0].length < 3) {\n    offsetX = 1\n  }\n\n  for (let y = 0; y < ruleArray.length; y++) {\n    for (let x = 0; x < ruleArray[y].length; x++) {\n      formatted[y+offsetY][x+offsetX] = ruleArray[y][x]\n    }\n  }\n\n  return formatted\n}\n\nfunction Rule({ when = [[]], then = [[]] }) {\n  this.when = format_matrix(when)\n  this.then = format_matrix(then)\n\n  this.match = function(grid, x, y) {\n    let element = grid[y][x]\n    // console.log('will try to match rule', this.when)\n    let matching = true\n    for (let _y = 0; _y < 3; _y++) {\n      for (let _x = 0; _x < 3; _x++) {\n        let symbol = this.when[_y][_x]\n        let value = grid[y+_y-1][x+_x-1]\n        switch (symbol) {\n          case '@':\n            if (value.name !== element.name) {\n              matching = false\n            }\n            break\n          case '.':\n            // it could be anything here\n            break\n          case '?':\n            if (value.name === empty.name) {\n              matching = false\n            }\n            break;\n          case '_':\n            if (value.name !== empty.name) {\n              matching = false\n            }\n            break;\n          case null:\n            // Do nothing\n            break\n          default:\n            if (value.name[0] !== symbol) {\n              matching = false\n            }\n        }\n      }\n    }\n    return matching\n  }\n\n  this.apply = function(grid, x, y) {\n    let element = grid[y][x]\n    // console.log('applying rule', this.then)\n    for (let _y = 0; _y < 3; _y++) {\n      for (let _x = 0; _x < 3; _x++) {\n        let symbol = this.then[_y][_x]\n        switch (symbol) {\n          case '@':\n            grid[y+_y-1][x+_x-1] = elements[element.name]\n            break\n          case '.':\n          case '?':\n          case null:\n            // Do nothing\n            break\n          case '_':\n              grid[y+_y-1][x+_x-1] = empty\n            break;\n          default:\n            grid[y+_y-1][x+_x-1] = elements[symbol]\n        }\n      }\n    }\n    return grid\n  }\n}\n\nfunction Element({ name = '_', rules = [], color = 'white' }) {\n  this.name = name\n  this.rules = rules\n  this.color = color\n}\n\nlet empty = new Element({ name: '_'})\nfunction clearGrid(grid) {\n  if (!grid) grid = []\n  for (let y = 0; y < GRID_HEIGHT; y++) {\n    grid[y] = []\n    for (let x = 0; x < GRID_WIDTH; x++) {\n      grid[y].push(empty)\n    }\n  }\n  return grid\n}\n\nlet elements = {}\n\nfor (let i = 65; i < 91; i++) {\n  let c = String.fromCharCode(i)\n  elements[c] = new Element({ name: `${c}` })\n}\n\nconst GRID_WIDTH = 30\nconst GRID_HEIGHT = 30\nlet grid = clearGrid()\n\nmodule.exports = {\n  GRID_WIDTH,\n  GRID_HEIGHT,\n  Rule: Rule,\n  Element: Element,\n  grid: grid,\n  elements: elements,\n  clearGrid: clearGrid\n}\n"]}